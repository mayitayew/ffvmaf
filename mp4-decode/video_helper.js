const BYTES_PER_SAMPLE = Uint8Array.BYTES_PER_ELEMENT;

class HeapVideoBuffer {
    /**
     * @constructor
     * @param  {object} wasmModule WASM module generated by Emscripten.
     * @param  {number} length Buffer frame length.
     */
    constructor(wasmModule, length) {
        this._isInitialized = false;
        this._module = wasmModule;
        this._length = length;
        this._allocateHeap();
        this._isInitialized = true;
    }

    /**
     * Allocates memory in the WASM heap and set up Uint8Array views for the
     * video data.
     *
     * @private
     */
    _allocateHeap() {
        const dataByteSize = this._length * BYTES_PER_SAMPLE;
        this._dataPtr = this._module._malloc(dataByteSize);
        // convert pointer to HEAPF32 index
        let startOffset = this._dataPtr;
        let endOffset = startOffset + this._length;
        this._videodata =
            this._module.HEAPU8.subarray(startOffset, endOffset);
    }

    /**
     * Getter for the buffer length in number of samples.
     *
     * @return {?number} Buffer length (aka number of samples).
     */
    get length() {
        return this._isInitialized ? this._length : null;
    }

    /**
     * Returns the reference to the array of video data.
     *
     * @param  {number|undefined} channelIndex Channel index.
     * @return {?Array} a channel data array or an
     * array of channel data.
     */
    getVideoData() {
        return this._videodata;
    }

    /**
     * Returns the base address of the allocated memory space in the WASM heap.
     *
     * @return {number} WASM Heap address.
     */
    getHeapAddress() {
        return this._dataPtr;
    }

    /**
     * Frees the allocated memory space in the WASM heap.
     */
    free() {
        this._isInitialized = false;
        this._module._free(this._dataPtr);
        this._channelData = null;
    }
};